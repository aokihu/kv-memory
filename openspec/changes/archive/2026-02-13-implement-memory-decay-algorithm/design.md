# Memory Decay Algorithm Design

## Context

当前记忆系统使用 SQLite 存储记忆节点，每个记忆包含 `key`、`summary`、`text`、`meta`、`links` 和 `created_at` 字段。记忆系统缺乏自动衰退机制，导致记忆节点无法根据使用频率、时间衰减和结构关系动态调整其活跃状态。这会导致系统积累大量低价值记忆，影响检索效率和系统性能。

**约束条件**：
1. 保持向后兼容性，不破坏现有 API 和数据结构
2. 使用 Bun 运行时环境
3. 遵循分层验证原则（Controller → Service → Lib）
4. 记忆分值是派生状态，不应被外部直接修改
5. 性能考虑：衰退计算不应阻塞正常操作

## Goals / Non-Goals

**Goals:**
1. 实现记忆衰退算法，基于使用行为、结构关系和时间衰减计算记忆得分（0-100）
2. 在记忆元数据中添加 `score` 字段，初始值 50
3. 实现定时任务系统，每15分钟自动执行衰退计算
4. 服务器启动时（HTTP/MCP）自动初始化定时任务
5. 基于得分实现记忆生命周期管理（active/cold/deprecated）
6. 提供记忆状态查询和过滤功能

**Non-Goals:**
1. 不修改现有记忆模型的核心结构（除添加 `score` 字段外）
2. 不改变记忆系统的外部接口（除可选的状态查询接口外）
3. 不引入新的外部依赖
4. 不实现复杂的机器学习算法（使用基于规则的衰退算法）

## Decisions

### 1. 得分计算算法设计

**决策**: 使用基于规则的加权得分算法，而非机器学习模型

**理由**:
- 更可预测和可调试
- 无需训练数据
- 参数可配置，易于调整
- 计算开销小

**算法公式**:
```
score = base_score * time_decay_factor + usage_boost + structure_boost
```

**参数**:
- `base_score`: 当前得分（初始 50）
- `time_decay_factor`: 时间衰减因子（0.95-1.0，基于时间间隔）
- `usage_boost`: 使用频率提升（0-10，基于访问次数）
- `structure_boost`: 结构重要性提升（0-5，基于链接数量和质量）

**替代方案考虑**:
- 机器学习模型：需要训练数据，计算开销大，可解释性差
- 简单时间衰减：无法考虑使用频率和结构关系

### 2. 数据库架构扩展

**决策**: 在 `memories` 表中添加 `score` INTEGER 列

**理由**:
- 与现有架构一致
- 支持高效的范围查询和排序
- 便于索引优化
- 默认值设为 50

**实现细节**:
```sql
ALTER TABLE memories ADD COLUMN score INTEGER DEFAULT 50 CHECK (score >= 0 AND score <= 100);
CREATE INDEX idx_memories_score ON memories(score);
```

**替代方案考虑**:
- 存储在 `meta` JSON 字段中：查询性能差，无法有效索引
- 单独的表：增加查询复杂度

### 3. 定时任务实现

**决策**: 使用 Bun 的 `setInterval` 实现轻量级定时任务

**理由**:
- 无外部依赖
- 与 Bun 运行时深度集成
- 简单可靠
- 支持动态调整间隔

**实现细节**:
```typescript
class DecayScheduler {
  private interval: Timer | null = null;
  
  start(intervalMs: number = 15 * 60 * 1000) {
    this.interval = setInterval(() => this.runDecay(), intervalMs);
  }
  
  stop() {
    if (this.interval) clearInterval(this.interval);
  }
}
```

**替代方案考虑**:
- `node-cron`: 功能更强大但增加依赖
- 外部任务队列（Bull/Agenda）：过度设计，增加复杂度

### 4. 并发安全设计

**决策**: 使用乐观锁和批处理确保并发安全

**理由**:
- 避免长时间锁定数据库
- 允许正常操作在衰退计算期间继续
- 减少内存占用

**实现策略**:
1. 分批处理记忆（例如每批100条）
2. 使用事务确保每批的原子性
3. 在批次间添加短暂延迟
4. 使用版本号或时间戳检测冲突

**替代方案考虑**:
- 悲观锁：可能导致长时间阻塞
- 无锁设计：实现复杂，可能数据不一致

### 5. 状态分类阈值

**决策**: 使用固定阈值分类记忆状态

**理由**:
- 简单直观
- 易于配置和调整
- 与业务逻辑解耦

**默认阈值**:
- Active: 70-100
- Cold: 30-69  
- Deprecated: 0-29

**替代方案考虑**:
- 动态阈值（基于百分位）：更灵活但计算开销大
- 机器学习分类：过度复杂

## Risks / Trade-offs

### [风险] 性能影响
- **风险**: 衰退计算可能影响系统性能，特别是记忆数量大时
- **缓解**: 
  - 使用批处理和增量更新
  - 在低峰时段运行
  - 可配置的批大小和处理间隔

### [风险] 数据一致性
- **风险**: 并发操作可能导致数据不一致
- **缓解**:
  - 使用事务确保原子性
  - 实现冲突检测和重试机制
  - 记录操作日志便于调试

### [风险] 内存泄漏
- **风险**: 定时任务可能导致内存泄漏
- **缓解**:
  - 定期清理临时数据
  - 实现内存使用监控
  - 提供手动停止和重启机制

### [风险] 向后兼容性
- **风险**: 现有代码可能依赖旧的记忆结构
- **缓解**:
  - 保持现有 API 不变
  - 提供数据迁移脚本
  - 详细的变更日志和文档

### [权衡] 计算精度 vs 性能
- **权衡**: 更精确的算法需要更多计算资源
- **决策**: 使用简化但有效的算法，优先保证系统响应性

### [权衡] 实时性 vs 资源使用
- **权衡**: 更频繁的计算提供更实时的得分，但消耗更多资源
- **决策**: 15分钟间隔提供合理平衡，可配置以适应不同场景

## Migration Plan

### 阶段 1: 数据库迁移
1. 创建迁移脚本添加 `score` 列
2. 为现有记忆初始化 `score = 50`
3. 创建索引优化查询性能

### 阶段 2: 核心算法实现
1. 实现衰退算法核心逻辑
2. 添加配置管理
3. 实现批处理和并发控制

### 阶段 3: 定时任务集成
1. 实现调度器
2. 集成到服务器启动流程
3. 添加监控和日志

### 阶段 4: 状态管理功能
1. 实现状态分类逻辑
2. 添加查询过滤支持
3. 可选：扩展 API 支持状态查询

### 阶段 5: 测试和部署
1. 单元测试和集成测试
2. 性能测试和负载测试
3. 分阶段部署和监控

### 回滚策略
1. 保留旧版本代码分支
2. 数据库变更可逆（可删除 `score` 列）
3. 功能开关控制新功能启用

## Open Questions

1. **得分计算的具体参数**：需要根据实际使用模式调整衰减因子和提升权重
2. **状态查询 API 的具体设计**：需要与前端团队协调接口设计
3. **监控指标定义**：需要确定哪些指标对监控系统健康最重要
4. **清理策略**：是否自动清理 deprecated 记忆，还是仅标记
5. **跨节点同步**：在分布式部署中如何同步得分计算