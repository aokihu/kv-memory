## Context

当前Memory数据结构包含domain和type字段，这两个字段在AGENTS.md中定义为：
- **domain**: 记忆的分类或领域标识
- **type**: 记忆的类型（如decision、constraint、bug、design等）

根据Athena的分析报告，这两个字段的使用频率较低，且功能可以被其他字段（如keywords、summary、text）替代。删除这两个字段可以简化系统架构，减少API复杂度，并降低数据存储开销。

**当前状态：**
- MemorySchema已修改，domain和type字段已从类型定义中删除
- 相关类型错误已出现，需要修复其他文件中的引用

**约束条件：**
- 需要保持向后兼容性，但允许破坏性变更
- 需要处理现有数据中的domain和type值
- 需要更新所有相关的测试用例

## Goals / Non-Goals

**Goals:**
1. 从Memory数据结构中完全移除domain和type字段
2. 更新所有相关的代码文件，消除类型错误
3. 确保系统功能完整性不受影响
4. 提供清晰的数据迁移策略
5. 更新所有相关文档

**Non-Goals:**
1. 不引入新的字段或功能
2. 不改变现有的API响应格式（除了删除字段）
3. 不重构其他不相关的代码部分
4. 不修改系统架构或引入新的依赖

## Decisions

### 1. 数据迁移策略
**决策**: 采用"软删除+默认值"策略
**理由**: 
- 现有数据中的domain和type值需要被处理
- 直接删除可能导致数据丢失
- 将domain和type的值合并到text字段中，添加注释标记
**替代方案考虑**:
  - 直接删除：简单但可能导致数据丢失
  - 保留但标记为废弃：需要维护兼容性代码
  - 迁移到新字段：需要额外的存储和处理逻辑

### 2. 数据库schema变更
**决策**: 使用ALTER TABLE语句删除列
**理由**:
- SQLite支持ALTER TABLE DROP COLUMN（需要SQLite 3.35.0+）
- 需要创建新表并迁移数据的方案更复杂
**实现步骤**:
  1. 创建新表（不包含domain和type列）
  2. 迁移数据
  3. 删除旧表
  4. 重命名新表

### 3. API兼容性处理
**决策**: 直接返回400错误，要求客户端更新
**理由**:
- 这是明确的破坏性变更
- 客户端应该明确知道需要更新
- 提供清晰的错误信息和迁移指南
**错误响应格式**:
```json
{
  "error": "domain_and_type_fields_removed",
  "message": "domain and type fields have been removed. Please update your client.",
  "migration_guide": "https://docs.example.com/migration"
}
```

### 4. 测试更新策略
**决策**: 更新所有测试用例，移除domain和type字段
**理由**:
- 确保测试覆盖所有修改
- 防止测试因字段不存在而失败
- 验证新功能的正确性

## Risks / Trade-offs

### [风险] 数据丢失
**缓解措施**: 
- 在迁移前备份数据库
- 将domain和type的值保存到text字段中
- 提供数据恢复脚本

### [风险] API客户端中断
**缓解措施**:
- 提前发布变更通知
- 提供详细的迁移文档
- 提供兼容性适配层（可选）

### [风险] 测试覆盖率下降
**缓解措施**:
- 运行完整的测试套件
- 添加新的测试用例验证字段删除后的功能
- 进行回归测试

### [风险] 文档不一致
**缓解措施**:
- 更新所有相关文档
- 验证文档与代码的一致性
- 添加文档更新检查到CI/CD

### 权衡考虑
- **简单性 vs. 兼容性**: 选择简单性，接受破坏性变更
- **开发速度 vs. 测试完整性**: 优先保证测试完整性
- **数据安全 vs. 迁移复杂度**: 优先保证数据安全