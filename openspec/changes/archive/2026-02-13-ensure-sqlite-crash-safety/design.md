## Context

当前项目使用SQLite作为Key-Value记忆系统的存储后端，支持HTTP API和MCP工具两种访问方式。项目采用双进程架构：HTTP服务器和MCP服务器可能同时访问同一个SQLite数据库文件。在之前的开发中，我们遇到了MCP运行时错误："[decay.scheduler][mcp] run failed: file is not a database"，这表明存在数据库连接和并发访问问题。

SQLite默认配置（`journal_mode = DELETE`, `synchronous = FULL`）在单进程场景下提供基本的数据安全性，但在多进程、服务器崩溃等场景下可能无法保证数据持久性。特别是：
1. 默认的DELETE日志模式在崩溃时可能丢失未提交的事务
2. 操作系统缓存可能导致已提交的数据未真正写入磁盘
3. 多进程访问需要WAL模式支持
4. 连接关闭时的事务处理可能不完整

## Goals / Non-Goals

**Goals:**
1. 确保服务器非正常退出（崩溃、断电、强制终止）时，已提交的事务数据不会丢失
2. 支持HTTP服务器和MCP服务器的并发安全访问
3. 提供可配置的持久性级别，平衡性能和数据安全性
4. 添加崩溃恢复机制，自动处理未完成的WAL事务
5. 保持向后兼容性，不破坏现有API和数据

**Non-Goals:**
1. 不更换数据库系统（保持SQLite作为存储后端）
2. 不重新设计应用架构
3. 不修改业务逻辑或数据模型
4. 不引入重大性能开销（在可接受范围内）

## Decisions

### 1. WAL模式启用
**决策：** 默认启用WAL（Write-Ahead Logging）模式
**理由：**
- WAL模式提供更好的并发性能，支持多进程读取和单进程写入
- 崩溃恢复更可靠：WAL日志可以重放未完成的事务
- 减少文件锁竞争，提高多进程访问的稳定性
- SQLite 3.7.0+ 版本广泛支持，Bun的`bun:sqlite`完全兼容

**替代方案考虑：**
- DELETE模式：传统日志模式，崩溃恢复能力较弱
- MEMORY模式：性能最好，但完全无持久性，不适合生产环境

### 2. 同步级别配置
**决策：** 使用`PRAGMA synchronous = EXTRA`
**理由：**
- EXTRA级别确保事务提交后数据真正写入磁盘，而不仅仅是操作系统缓存
- 提供最高级别的崩溃安全性
- 性能开销在可接受范围内（相比FULL级别增加约10-20%）

**替代方案考虑：**
- FULL：默认级别，数据在事务提交时写入，但可能仍在OS缓存
- NORMAL：性能更好，但崩溃时可能丢失最近的事务
- OFF：无同步，性能最好但数据安全性最低

### 3. 事务管理策略
**决策：** 所有写操作必须在显式事务中执行
**理由：**
- 确保操作的原子性和一致性
- 提供明确的提交点，便于崩溃恢复
- 符合SQLite的最佳实践

**实现方式：**
- 服务层方法（如`addMemory`, `updateMemory`）自动包装在事务中
- 提供事务辅助函数，简化事务管理
- 确保事务提交后执行`PRAGMA wal_checkpoint`（可选）

### 4. 连接配置优化
**决策：** 统一数据库连接配置
**理由：**
- 确保HTTP服务器和MCP服务器使用相同的持久性配置
- 避免配置不一致导致的数据一致性问题

**具体配置：**
```typescript
PRAGMA journal_mode = WAL;
PRAGMA synchronous = EXTRA;
PRAGMA busy_timeout = 5000;  // 5秒超时
PRAGMA cache_size = -64000;  // 64MB缓存
PRAGMA temp_store = MEMORY;  // 临时表使用内存
```

### 5. 崩溃恢复机制
**决策：** 启动时自动执行WAL检查和恢复
**理由：**
- 自动处理上次异常退出遗留的WAL文件
- 确保数据库处于一致状态
- 无需人工干预

**实现方式：**
- 数据库连接初始化时执行`PRAGMA wal_checkpoint(TRUNCATE)`
- 如果检测到hot WAL文件，自动执行恢复
- 记录恢复日志，便于监控

## Risks / Trade-offs

### 风险1：性能下降
**风险：** EXTRA同步级别和WAL模式可能降低写入性能
**缓解：**
- 基准测试验证实际性能影响
- 提供配置选项，允许根据场景调整同步级别
- 优化事务大小，避免过大的单次事务

### 风险2：WAL文件管理
**风险：** WAL文件可能持续增长，占用磁盘空间
**缓解：**
- 定期执行`PRAGMA wal_checkpoint(TRUNCATE)`
- 监控WAL文件大小
- 添加自动清理机制

### 风险3：多进程兼容性
**风险：** 现有代码可能假设单进程访问模式
**缓解：**
- 全面测试HTTP服务器和MCP服务器的并发访问
- 确保所有数据库操作正确处理锁超时
- 添加重试机制处理`SQLITE_BUSY`错误

### 风险4：配置传播
**风险：** 配置修改可能未应用到所有数据库连接
**缓解：**
- 统一数据库连接工厂函数
- 确保HTTP服务器和MCP服务器使用相同的配置
- 添加配置验证测试

### 权衡：持久性 vs 性能
**权衡：** 更高的数据安全性带来一定的性能开销
**决策：** 优先保证数据安全性，性能优化作为后续工作
**理由：** 数据丢失是不可接受的，而性能下降可以通过其他方式优化（如缓存、批量操作）

## Migration Plan

### 阶段1：配置分析和测试
1. 分析当前SQLite配置状态
2. 创建测试环境，模拟崩溃场景
3. 验证现有配置的数据丢失风险

### 阶段2：配置修改
1. 更新数据库连接配置，启用WAL模式和EXTRA同步
2. 确保所有写操作使用显式事务
3. 添加启动时的WAL恢复逻辑

### 阶段3：测试验证
1. 单元测试：验证配置生效
2. 集成测试：模拟服务器崩溃，验证数据持久性
3. 性能测试：评估配置修改的性能影响
4. 并发测试：验证多进程访问的稳定性

### 阶段4：部署
1. 开发环境部署验证
2. 测试环境全面测试
3. 生产环境灰度发布
4. 监控数据持久性和性能指标

### 回滚策略
1. 配置修改可随时回退到默认值
2. WAL模式向后兼容，可切换回DELETE模式
3. 如果发现问题，立即回滚配置并调查根本原因

## Open Questions

1. **性能影响量化：** EXTRA同步级别的实际性能影响需要基准测试数据
2. **WAL检查点策略：** 自动检查点的触发条件和频率需要优化
3. **监控指标：** 需要定义哪些指标来监控数据持久性和WAL状态
4. **配置灵活性：** 是否应该提供运行时配置切换，允许根据负载调整同步级别