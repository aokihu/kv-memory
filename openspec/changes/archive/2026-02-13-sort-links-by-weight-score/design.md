## Context

记忆衰退算法已经成功实现，为每个记忆添加了score字段（0-100范围）。然而，当前系统在返回记忆数据时，Links数组的排序未能充分利用这个新的score信息。用户需要Links数组按照 `link weight × score` 进行从高到低排序，以反映记忆的"综合重要性"。

当前系统架构：
- 记忆数据存储在SQLite数据库中，包含links数组
- link weight是0-1范围的浮点数，表示链接强度
- memory score是0-100范围的整数，表示记忆重要性
- 查询逻辑集中在 `src/libs/kv/db/query.ts`
- API层在controller中，服务层处理业务逻辑

## Goals / Non-Goals

**Goals:**
1. 实现Links数组按 `link weight × score` 综合得分排序
2. 保持向后兼容性，现有客户端无需修改
3. 提供可选的排序控制参数
4. 确保排序算法高效，不影响查询性能
5. 统一处理HTTP API的排序逻辑

**Future Enhancements:**
- MCP工具集成（可在后续迭代中实现）

**Non-Goals:**
1. 修改score计算算法本身
2. 修改link weight的计算方式
3. 重新设计数据库schema
4. 影响非Links数组的其他排序
5. 添加复杂的排序配置选项

## Decisions

### 1. 排序算法位置：服务层 vs 数据库层
**决策**：在服务层实现排序算法
**理由**：
- 数据库层已返回原始数据，包含link weight和memory score
- 服务层可以灵活处理复杂的排序逻辑（包括平局处理）
- 避免复杂的SQL查询和可能的性能问题
- 便于添加可选的排序控制参数

**替代方案考虑**：
- 数据库层排序：需要复杂的JOIN查询获取linked memory的score，性能可能较差
- 客户端排序：不符合服务端控制的原则，客户端实现不一致

### 2. 排序实现方式：内存排序 vs 数据库索引
**决策**：使用内存排序
**理由**：
- 大多数记忆的links数量有限（通常<100）
- 内存排序简单高效，易于实现和维护
- 可以灵活处理各种边界情况（null score、平局等）
- 不需要修改数据库schema或添加索引

**性能考虑**：
- 对于links数量大的记忆（>1000），排序时间控制在100ms内
- 使用高效的排序算法（Array.prototype.sort）
- 考虑批量查询时的优化

### 3. 默认行为：启用排序 vs 可选排序
**决策**：默认启用排序，提供可选参数控制
**理由**：
- 向后兼容：现有客户端自动获得更好的排序体验
- 渐进增强：新客户端可以选择禁用排序
- 符合"明智的默认值"原则

**参数设计**：
- `sortLinks=true` (默认)：启用综合得分排序
- `sortLinks=false`：禁用排序，返回原始顺序

### 4. 平局处理策略
**决策**：三级平局处理
**理由**：
1. 第一级：`link weight × score` 综合得分（降序）
2. 第二级：link weight（降序）
3. 第三级：memory key（字母顺序）

**确保**：排序结果稳定且可预测

### 5. 缺失score的处理
**决策**：使用默认值50
**理由**：
- 保持与记忆衰退算法的一致性（初始score为50）
- 避免因缺失score而排除链接
- 提供合理的默认行为

## Risks / Trade-offs

### [风险] 性能影响
- **风险**：对大量links的记忆进行排序可能影响查询性能
- **缓解**：
  - 实现性能测试，确保排序时间在可接受范围内
  - 考虑对超多links的记忆进行优化（如限制排序数量）
  - 添加性能监控，跟踪排序操作耗时

### [风险] 内存使用
- **风险**：同时处理多个记忆的排序可能增加内存使用
- **缓解**：
  - 使用流式处理，避免一次性加载所有数据
  - 实现批处理限制，控制并发排序数量
  - 监控内存使用情况

### [风险] 排序稳定性
- **风险**：不同运行环境下排序结果可能不一致
- **缓解**：
  - 使用稳定的排序算法
  - 明确定义平局处理规则
  - 添加单元测试验证排序稳定性

### [权衡] 功能复杂度 vs 用户体验
- **权衡**：简单的实现 vs 丰富的功能
- **决策**：优先保持简单，逐步增强
- **理由**：核心需求是基本排序功能，复杂功能可以后续迭代

## Migration Plan

### 部署步骤
1. **开发阶段**：
   - 实现排序算法和测试
   - 更新API文档
   - 性能测试和优化

2. **测试阶段**：
   - 单元测试验证排序逻辑
   - 集成测试验证端到端行为
   - 性能测试验证无显著性能下降

3. **部署阶段**：
   - 合并代码到主分支
   - 部署到测试环境验证
   - 监控性能指标
   - 逐步部署到生产环境

### 回滚策略
- **回滚触发条件**：发现严重性能问题或排序逻辑错误
- **回滚步骤**：
  1. 恢复代码到前一版本
  2. 清除相关配置变更
  3. 验证系统功能恢复正常
- **数据影响**：无数据迁移需求，纯代码变更

## Open Questions

1. **排序参数扩展**：是否需要支持其他排序方式（如仅按weight、仅按score）？
   - **当前决策**：暂不实现，保持简单
   - **未来考虑**：根据用户反馈决定是否添加

2. **性能监控指标**：需要监控哪些具体指标来评估排序性能？
   - **建议**：排序耗时、内存使用、查询响应时间

3. **客户端适配**：是否需要通知客户端开发者关于排序行为的变化？
   - **决策**：通过API文档更新通知，由于是向后兼容的增强，不需要强制客户端更新